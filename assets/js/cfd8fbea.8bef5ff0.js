"use strict";(self.webpackChunksolidspoon_site=self.webpackChunksolidspoon_site||[]).push([[2171],{1623:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>h});var n=i(5893),s=i(1151);const a={slug:"distributed-locks-with-redis",title:"Distributed locks with Redis",authors:["solidSpoon"],tags:[]},l="Distributed locks with Redis",r={permalink:"/blog/distributed-locks-with-redis",editUrl:"https://github.com/solidSpoon/solidSpoon.github.io/tree/main/packages/create-docusaurus/templates/shared/blog/2022/03-23-distributed-locks-with-redis/index.md",source:"@site/blog/2022/03-23-distributed-locks-with-redis/index.md",title:"Distributed locks with Redis",description:"\u539f\u6587\u94fe\u63a5\uff1ahttps://redis.io/topics/distlock",date:"2022-03-23T00:00:00.000Z",formattedDate:"2022\u5e743\u670823\u65e5",tags:[],readingTime:36.455,hasTruncateMarker:!1,authors:[{name:"solidSpoon",title:"Maintainer of Hide",url:"https://github.com/solidSpoon",imageURL:"https://github.com/solidSpoon.png",key:"solidSpoon"}],frontMatter:{slug:"distributed-locks-with-redis",title:"Distributed locks with Redis",authors:["solidSpoon"],tags:[]},unlisted:!1,prevItem:{title:"MongoDB \u521d\u63a2",permalink:"/blog/exploring-mongodb"},nextItem:{title:"ClashForWindows tap \u6a21\u5f0f\u65e0\u6cd5\u6b63\u5e38\u8fde\u63a5\u7f51\u7edc",permalink:"/blog/clash-for-windows-tap-mode-cannot-connect-to-network-normally"}},o={authorsImageUrls:[void 0]},h=[{value:"Background",id:"background",level:2},{value:"Implementations",id:"implementations",level:2},{value:"Safety and Liveness guarantees",id:"safety-and-liveness-guarantees",level:2},{value:"Why failover-based implementations are not enough",id:"why-failover-based-implementations-are-not-enough",level:2},{value:"Correct implementation with a single instance",id:"correct-implementation-with-a-single-instance",level:2},{value:"The Redlock algorithm",id:"the-redlock-algorithm",level:2},{value:"Is the algorithm asynchronous?",id:"is-the-algorithm-asynchronous",level:2},{value:"Retry on failure",id:"retry-on-failure",level:2},{value:"Releasing the lock",id:"releasing-the-lock",level:2},{value:"Safety arguments",id:"safety-arguments",level:2},{value:"Liveness arguments",id:"liveness-arguments",level:2},{value:"Performance, crash-recovery and fsync",id:"performance-crash-recovery-and-fsync",level:2},{value:"Making the algorithm more reliable: Extending the lock",id:"making-the-algorithm-more-reliable-extending-the-lock",level:2},{value:"Want to help?",id:"want-to-help",level:2}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["\u539f\u6587\u94fe\u63a5\uff1a",(0,n.jsx)(t.a,{href:"https://redis.io/topics/distlock",children:"https://redis.io/topics/distlock"})]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,n.jsx)(t.p,{children:"Distributed locks are a very useful primitive in many environments where different processes must operate with shared resources in a mutually exclusive way."}),"\n",(0,n.jsx)(t.p,{children:"\u5206\u5e03\u5f0f\u9501\u5728\u8bb8\u591a\u73af\u5883\u4e2d\u662f\u975e\u5e38\u6709\u7528\u7684\u539f\u8bed\uff0c\u5728\u8fd9\u4e9b\u73af\u5883\u4e2d\u4e0d\u540c\u7684\u8fdb\u7a0b\u5fc5\u987b\u4ee5\u4e92\u65a5\u7684\u65b9\u5f0f\u4f7f\u7528\u5171\u4eab\u8d44\u6e90\u3002"}),"\n",(0,n.jsx)(t.p,{children:"There are a number of libraries and blog posts describing how to implement a DLM (Distributed Lock Manager) with Redis, but every library uses a different approach, and many use a simple approach with lower guarantees compared to what can be achieved with slightly more complex designs."}),"\n",(0,n.jsx)(t.p,{children:"\u6709\u8bb8\u591a\u5e93\u548c\u535a\u5ba2\u6587\u7ae0\u63cf\u8ff0\u4e86\u5982\u4f55\u4f7f\u7528 Redis \u5b9e\u73b0 DLM\uff08\u5206\u5e03\u5f0f\u9501\u7ba1\u7406\u5668\uff09\uff0c\u4f46\u662f\u6bcf\u4e2a\u5e93\u90fd\u4f7f\u7528\u4e0d\u540c\u7684\u65b9\u6cd5\uff0c\u5e76\u4e14\u4e0e\u7a0d\u5fae\u590d\u6742\u4e00\u70b9\u7684\u5e93\u76f8\u6bd4\uff0c\u8bb8\u591a\u5e93\u4f7f\u7528\u7684\u4fdd\u8bc1\u8f83\u4f4e\u7684\u7b80\u5355\u65b9\u6cd5\u8bbe\u8ba1\u3002"}),"\n",(0,n.jsxs)(t.p,{children:["This page is an attempt to provide a more canonical algorithm to implement distributed locks with Redis. We propose an algorithm, called ",(0,n.jsx)(t.strong,{children:"Redlock"}),", which implements a DLM which we believe to be safer than the vanilla single instance approach. We hope that the community will analyze it, provide feedback, and use it as a starting point for the implementations or more complex or alternative designs."]}),"\n",(0,n.jsxs)(t.p,{children:["\u672c\u9875\u8bd5\u56fe\u63d0\u4f9b\u4e00\u79cd\u66f4\u89c4\u8303\u7684\u7b97\u6cd5\u6765\u4f7f\u7528 Redis \u5b9e\u73b0\u5206\u5e03\u5f0f\u9501\u3002\u6211\u4eec\u63d0\u51fa\u4e86\u4e00\u79cd\u79f0\u4e3a ",(0,n.jsx)(t.strong,{children:"Redlock"})," \u7684\u7b97\u6cd5\uff0c\u5b83\u5b9e\u73b0\u4e86\u4e00\u4e2a\u6211\u4eec\u8ba4\u4e3a\u6bd4\u666e\u901a\u5355\u5b9e\u4f8b\u65b9\u6cd5\u66f4\u5b89\u5168\u7684 DLM\u3002\u6211\u4eec\u5e0c\u671b\u793e\u533a\u80fd\u591f\u5bf9\u5176\u8fdb\u884c\u5206\u6790\uff0c\u63d0\u4f9b\u53cd\u9988\uff0c\u5e76\u5c06\u5176\u7528\u4f5c\u5b9e\u65bd\u6216\u66f4\u590d\u6742\u6216\u66ff\u4ee3\u8bbe\u8ba1\u7684\u8d77\u70b9\u3002"]}),"\n",(0,n.jsx)(t.h2,{id:"implementations",children:"Implementations"}),"\n",(0,n.jsx)(t.p,{children:"Before describing the algorithm, here are a few links to implementations already available that can be used for reference."}),"\n",(0,n.jsx)(t.p,{children:"\u5728\u63cf\u8ff0\u7b97\u6cd5\u4e4b\u524d\uff0c\u8fd9\u91cc\u6709\u4e00\u4e9b\u5df2\u7ecf\u53ef\u7528\u7684\u5b9e\u73b0\u94fe\u63a5\uff0c\u53ef\u4f9b\u53c2\u8003\u3002"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/antirez/redlock-rb",children:"Redlock-rb"})," (Ruby implementation). There is also a ",(0,n.jsx)(t.a,{href:"https://github.com/leandromoreira/redlock-rb",children:"fork of Redlock-rb"})," that adds a gem for easy distribution and perhaps more."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/SPSCommerce/redlock-py",children:"Redlock-py"})," (Python implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/brainix/pottery#redlock",children:"Pottery"})," (Python implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/joanvila/aioredlock",children:"Aioredlock"})," (Asyncio Python implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/ronnylt/redlock-php",children:"Redlock-php"})," (PHP implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/malkusch/lock#phpredismutex",children:"PHPRedisMutex"})," (further PHP implementation)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/cheprasov/php-redis-lock",children:"cheprasov/php-redis-lock"})," (PHP library for locks)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/rtckit/reactphp-redlock",children:"rtckit/react-redlock"})," (Async PHP implementation)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/go-redsync/redsync",children:"Redsync"})," (Go implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/mrniko/redisson",children:"Redisson"})," (Java implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/sbertrang/redis-distlock",children:"Redis::DistLock"})," (Perl implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/jacket-code/redlock-cpp",children:"Redlock-cpp"})," (C++ implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/kidfashion/redlock-cs",children:"Redlock-cs"})," (C#/.NET implementation)."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/samcook/RedLock.net",children:"RedLock.net"})," (C#/.NET implementation). Includes async and lock extension support."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/psibernetic/scarletlock",children:"ScarletLock"})," (C# .NET implementation with configurable datastore)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/LiZhenNet/Redlock4Net",children:"Redlock4Net"})," (C# .NET implementation)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://github.com/mike-marcacci/node-redlock",children:"node-redlock"})," (NodeJS implementation). Includes support for lock extension."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"safety-and-liveness-guarantees",children:"Safety and Liveness guarantees"}),"\n",(0,n.jsx)(t.p,{children:"We are going to model our design with just three properties that, from our point of view, are the minimum guarantees needed to use distributed locks in an effective way."}),"\n",(0,n.jsx)(t.p,{children:"\u6211\u4eec\u5c06\u4ec5\u4f7f\u7528\u4e09\u4e2a\u5c5e\u6027\u5bf9\u6211\u4eec\u7684\u8bbe\u8ba1\u8fdb\u884c\u5efa\u6a21\uff0c\u4ece\u6211\u4eec\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u8fd9\u4e9b\u5c5e\u6027\u662f\u6709\u6548\u4f7f\u7528\u5206\u5e03\u5f0f\u9501\u6240\u9700\u7684\u6700\u4f4e\u4fdd\u8bc1\u3002"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Safety property: Mutual exclusion. At any given moment, only one client can hold a lock."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Liveness property A: Deadlock free. Eventually it is always possible to acquire a lock, even if the client that locked a resource crashes or gets partitioned."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Liveness property B: Fault tolerance. As long as the majority of Redis nodes are up, clients are able to acquire and release locks."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u5b89\u5168\u6027\uff1a\u4e92\u65a5\u3002\u5728\u4efb\u4f55\u7ed9\u5b9a\u65f6\u523b\uff0c\u53ea\u6709\u4e00\u4e2a\u5ba2\u6237\u7aef\u53ef\u4ee5\u6301\u6709\u9501\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Liveness property A: \u65e0\u6b7b\u9501\u3002\u6700\u7ec8\uff0c\u5373\u4f7f\u9501\u5b9a\u8d44\u6e90\u7684\u5ba2\u6237\u7aef\u5d29\u6e83\u6216\u88ab\u5206\u533a\uff0c\u4e5f\u603b\u662f\u53ef\u4ee5\u83b7\u5f97\u9501\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Liveness property B: \u5bb9\u9519\u3002\u53ea\u8981\u5927\u591a\u6570 Redis \u8282\u70b9\u90fd\u542f\u52a8\uff0c\u5ba2\u6237\u7aef\u5c31\u53ef\u4ee5\u83b7\u53d6\u548c\u91ca\u653e\u9501\u3002"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"why-failover-based-implementations-are-not-enough",children:"Why failover-based implementations are not enough"}),"\n",(0,n.jsx)(t.p,{children:"To understand what we want to improve, let\u2019s analyze the current state of affairs with most Redis-based distributed lock libraries."}),"\n",(0,n.jsx)(t.p,{children:"\u4e3a\u4e86\u4e86\u89e3\u6211\u4eec\u60f3\u8981\u6539\u8fdb\u7684\u5730\u65b9\uff0c\u8ba9\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u5927\u591a\u6570\u57fa\u4e8e Redis \u7684\u5206\u5e03\u5f0f\u9501\u5e93\u7684\u73b0\u72b6\u3002"}),"\n",(0,n.jsxs)(t.p,{children:["The simplest way to use Redis to lock a resource is to create a key in an instance. The key is usually created with a limited ",(0,n.jsx)(t.strong,{children:"time to live"}),", using the Redis expires feature, so that eventually it will get released (property 2 in our list). When the client needs to release the resource, it deletes the key."]}),"\n",(0,n.jsx)(t.p,{children:"\u4f7f\u7528 Redis \u9501\u5b9a\u8d44\u6e90\u7684\u6700\u7b80\u5355\u65b9\u6cd5\u662f\u5728\u5b9e\u4f8b\u4e2d\u521b\u5efa key\u3002key \u901a\u5e38\u662f\u4f7f\u7528 Redis \u8fc7\u671f\u529f\u80fd\u5728\u6709\u9650\u7684\u65f6\u95f4\u5185\u521b\u5efa\u7684\uff0c\u56e0\u6b64\u6700\u7ec8\u5b83\u4f1a\u88ab\u91ca\u653e\uff08\u6211\u4eec\u5217\u8868\u4e2d\u7684\u5c5e\u6027 2\uff09\u3002\u5f53\u5ba2\u6237\u7aef\u9700\u8981\u91ca\u653e\u8d44\u6e90\u65f6\uff0c\u5b83\u4f1a\u5220\u9664 key\u3002"}),"\n",(0,n.jsx)(t.p,{children:"Superficially this works well, but there is a problem: this is a single point of failure in our architecture. What happens if the Redis master goes down? Well, let\u2019s add a replica! And use it if the master is unavailable. This is unfortunately not viable. By doing so we can\u2019t implement our safety property of mutual exclusion, because Redis replication is asynchronous."}),"\n",(0,n.jsx)(t.p,{children:"\u4ece\u8868\u9762\u4e0a\u770b\uff0c\u8fd9\u5f88\u597d\u7528\uff0c\u4f46\u6709\u4e00\u4e2a\u95ee\u9898\uff1a\u8fd9\u662f\u6211\u4eec\u67b6\u6784\u4e2d\u7684\u5355\u70b9\u6545\u969c\u3002\u5982\u679c Redis master \u5b95\u673a\u4e86\u600e\u4e48\u529e\uff1f\u597d\u5427\uff0c\u8ba9\u6211\u4eec\u6dfb\u52a0\u4e00\u4e2a\u526f\u672c\uff01\u5982\u679c master \u4e0d\u53ef\u7528\uff0c\u8bf7\u4f7f\u7528\u5b83\u3002\u4e0d\u5e78\u7684\u662f\uff0c\u8fd9\u662f\u4e0d\u53ef\u884c\u7684\u3002\u8fd9\u6837\u505a\u6211\u4eec\u65e0\u6cd5\u5b9e\u73b0\u4e92\u65a5\u7684\u5b89\u5168\u5c5e\u6027\uff0c\u56e0\u4e3a Redis \u590d\u5236\u662f\u5f02\u6b65\u7684\u3002"}),"\n",(0,n.jsx)(t.p,{children:"There is an obvious race condition with this model:"}),"\n",(0,n.jsx)(t.p,{children:"\u8fd9\u4e2a\u6a21\u578b\u6709\u4e00\u4e2a\u660e\u663e\u7684\u7ade\u4e89\u6761\u4ef6\uff1a"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Client A acquires the lock in the master."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The master crashes before the write to the key is transmitted to the replica."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The replica gets promoted to master."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["Client B acquires the lock to the same resource A already holds a lock for. ",(0,n.jsx)(t.strong,{children:"SAFETY VIOLATION!"})]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u5ba2\u6237\u7aef A \u83b7\u53d6 master \u4e2d\u7684\u9501\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"master \u5728\u5bf9 key \u7684\u5199\u5165\u4f20\u8f93\u5230 replica \u4e4b\u524d\u5d29\u6e83\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"replica \u88ab\u63d0\u5347\u4e3a master\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:["\u5ba2\u6237\u7aef B \u83b7\u53d6 A \u5df2\u7ecf\u6301\u6709\u9501\u7684\u540c\u4e00\u8d44\u6e90\u7684\u9501\u3002 ",(0,n.jsx)(t.strong,{children:"\u8fdd\u53cd\u5b89\u5168\u89c4\u5b9a\uff01"})]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Sometimes it is perfectly fine that under special circumstances, like during a failure, multiple clients can hold the lock at the same time. If this is the case, you can use your replication based solution. Otherwise we suggest to implement the solution described in this document."}),"\n",(0,n.jsx)(t.p,{children:"\u6709\u65f6\u5728\u7279\u6b8a\u60c5\u51b5\u4e0b\uff08\u4f8b\u5982\u5728\u6545\u969c\u671f\u95f4\uff09\uff0c\u591a\u4e2a\u5ba2\u6237\u7aef\u53ef\u4ee5\u540c\u65f6\u6301\u6709\u9501\u662f\u5b8c\u5168\u53ef\u4ee5\u7684\u3002\u5982\u679c\u662f\u8fd9\u79cd\u60c5\u51b5\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u57fa\u4e8e\u590d\u5236\u7684\u89e3\u51b3\u65b9\u6848\u3002\u5426\u5219\uff0c\u6211\u4eec\u5efa\u8bae\u5b9e\u65bd\u672c\u6587\u6863\u4e2d\u63cf\u8ff0\u7684\u89e3\u51b3\u65b9\u6848\u3002"}),"\n",(0,n.jsx)(t.h2,{id:"correct-implementation-with-a-single-instance",children:"Correct implementation with a single instance"}),"\n",(0,n.jsx)(t.p,{children:"Before trying to overcome the limitation of the single instance setup described above, let\u2019s check how to do it correctly in this simple case, since this is actually a viable solution in applications where a race condition from time to time is acceptable, and because locking into a single instance is the foundation we\u2019ll use for the distributed algorithm described here."}),"\n",(0,n.jsx)(t.p,{children:"\u5728\u5c1d\u8bd5\u514b\u670d\u4e0a\u8ff0\u5355\u5b9e\u4f8b\u8bbe\u7f6e\u7684\u9650\u5236\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u68c0\u67e5\u4e00\u4e0b\u5982\u4f55\u5728\u8fd9\u4e2a\u7b80\u5355\u7684\u60c5\u51b5\u4e0b\u6b63\u786e\u5730\u505a\u5230\u8fd9\u4e00\u70b9\uff0c\u56e0\u4e3a\u5728\u4e0d\u65f6\u51fa\u73b0\u7ade\u4e89\u6761\u4ef6\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u8fd9\u5b9e\u9645\u4e0a\u662f\u4e00\u4e2a\u53ef\u884c\u7684\u89e3\u51b3\u65b9\u6848\uff0c\u5e76\u4e14\u56e0\u4e3a\u9501\u5b9a\u5230\u5355\u4e2a\u5b9e\u4f8b\u662f\u6211\u4eec\u5c06\u7528\u4e8e\u6b64\u5904\u63cf\u8ff0\u7684\u5206\u5e03\u5f0f\u7b97\u6cd5\u7684\u57fa\u7840\u3002"}),"\n",(0,n.jsx)(t.p,{children:"To acquire the lock, the way to go is the following:"}),"\n",(0,n.jsx)(t.p,{children:"\u83b7\u53d6\u9501\u7684\u65b9\u6cd5\u5982\u4e0b\uff1a"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-bash",children:"SET resource_name my_random_value NX PX 30000\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The command will set the key only if it does not already exist (NX option), with an expire of 30000 milliseconds (PX option). The key is set to a value \u201c",(0,n.jsx)(t.code,{children:"my_random_value"}),"\u201d. This value must be unique across all clients and all lock requests."]}),"\n",(0,n.jsxs)(t.p,{children:["\u8be5\u547d\u4ee4\u4ec5\u5728\u5bc6\u94a5\u4e0d\u5b58\u5728\u65f6\u8bbe\u7f6e\u5bc6\u94a5\uff08NX option\uff09\uff0c\u8fc7\u671f\u65f6\u95f4\u4e3a 30000 \u6beb\u79d2\uff08PX option\uff09\u3002\u5bc6\u94a5\u8bbe\u7f6e\u4e3a\u503c",(0,n.jsx)(t.code,{children:"my_random_value"}),"\u3002\u6b64\u503c\u5728\u6240\u6709\u5ba2\u6237\u7aef\u548c\u6240\u6709\u9501\u5b9a\u8bf7\u6c42\u4e2d\u5fc5\u987b\u662f\u552f\u4e00\u7684\u3002"]}),"\n",(0,n.jsx)(t.p,{children:"Basically the random value is used in order to release the lock in a safe way, with a script that tells Redis: remove the key only if it exists and the value stored at the key is exactly the one I expect to be. This is accomplished by the following Lua script:"}),"\n",(0,n.jsx)(t.p,{children:"\u57fa\u672c\u4e0a\uff0c\u968f\u673a\u503c\u7528\u4e8e\u4ee5\u5b89\u5168\u7684\u65b9\u5f0f\u91ca\u653e\u9501\uff0c\u811a\u672c\u544a\u8bc9 Redis\uff1a\u4ec5\u5f53\u5bc6\u94a5\u5b58\u5728\u5e76\u4e14\u5b58\u50a8\u5728\u5bc6\u94a5\u4e2d\u7684\u503c\u6b63\u662f\u6211\u671f\u671b\u7684\u503c\u65f6\u624d\u5220\u9664\u5bc6\u94a5\u3002\u8fd9\u662f\u901a\u8fc7\u4ee5\u4e0b Lua \u811a\u672c\u5b8c\u6210\u7684\uff1a"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-lua",children:'if redis.call("get",KEYS[1]) == ARGV[1] then\n    return redis.call("del",KEYS[1])\nelse\n    return 0\nend\n'})}),"\n",(0,n.jsx)(t.p,{children:"This is important in order to avoid removing a lock that was created by another client. For example a client may acquire the lock, get blocked in some operation for longer than the lock validity time (the time at which the key will expire), and later remove the lock, that was already acquired by some other client. Using just DEL is not safe as a client may remove the lock of another client. With the above script instead every lock is \u201csigned\u201d with a random string, so the lock will be removed only if it is still the one that was set by the client trying to remove it."}),"\n",(0,n.jsx)(t.p,{children:"\u8fd9\u5bf9\u4e8e\u907f\u514d\u5220\u9664\u7531\u53e6\u4e00\u4e2a\u5ba2\u6237\u7aef\u521b\u5efa\u7684\u9501\u5f88\u91cd\u8981\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u5ba2\u6237\u7aef\u53ef\u80fd\u83b7\u53d6\u4e86\u9501\uff0c\u5728\u67d0\u4e2a\u64cd\u4f5c\u4e2d\u88ab\u963b\u585e\u7684\u65f6\u95f4\u8d85\u8fc7\u4e86\u9501\u7684\u6709\u6548\u65f6\u95f4\uff08\u5bc6\u94a5\u8fc7\u671f\u7684\u65f6\u95f4\uff09\uff0c\u7136\u540e\u79fb\u9664\u4e86\u5df2\u7ecf\u88ab\u5176\u4ed6\u5ba2\u6237\u7aef\u83b7\u53d6\u7684\u9501\u3002\u4ec5\u4f7f\u7528 DEL \u662f\u4e0d\u5b89\u5168\u7684\uff0c\u56e0\u4e3a\u5ba2\u6237\u7aef\u53ef\u80fd\u4f1a\u5220\u9664\u53e6\u4e00\u4e2a\u5ba2\u6237\u7aef\u7684\u9501\u5b9a\u3002\u4f7f\u7528\u4e0a\u9762\u7684\u811a\u672c\uff0c\u6bcf\u4e2a\u9501\u90fd\u7528\u4e00\u4e2a\u968f\u673a\u5b57\u7b26\u4e32\u201c\u7b7e\u540d\u201d\uff0c\u6240\u4ee5\u53ea\u6709\u5f53\u5b83\u4ecd\u7136\u662f\u5ba2\u6237\u7aef\u8bd5\u56fe\u79fb\u9664\u5b83\u65f6\u8bbe\u7f6e\u7684\u9501\u624d\u4f1a\u88ab\u79fb\u9664\u3002"}),"\n",(0,n.jsx)(t.p,{children:"What should this random string be? I assume it\u2019s 20 bytes from /dev/urandom, but you can find cheaper ways to make it unique enough for your tasks. For example a safe pick is to seed RC4 with /dev/urandom, and generate a pseudo random stream from that. A simpler solution is to use a combination of unix time with microseconds resolution, concatenating it with a client ID, it is not as safe, but probably up to the task in most environments."}),"\n",(0,n.jsx)(t.p,{children:"\u8fd9\u4e2a\u968f\u673a\u5b57\u7b26\u4e32\u5e94\u8be5\u662f\u4ec0\u4e48\uff1f\u6211\u5047\u8bbe\u5b83\u662f /dev/urandom \u4e2d\u7684 20 \u4e2a\u5b57\u8282\uff0c\u4f46\u60a8\u53ef\u4ee5\u627e\u5230\u66f4\u4fbf\u5b9c\u7684\u65b9\u6cd5\u6765\u4f7f\u5176\u5bf9\u60a8\u7684\u4efb\u52a1\u8db3\u591f\u72ec\u7279\u3002\u4f8b\u5982\uff0c\u4e00\u4e2a\u5b89\u5168\u7684\u9009\u62e9\u662f\u4f7f\u7528 /dev/urandom \u4f5c\u4e3a RC4 \u7684\u79cd\u5b50\uff0c\u5e76\u4ece\u4e2d\u751f\u6210\u4e00\u4e2a\u4f2a\u968f\u673a\u6d41\u3002\u4e00\u4e2a\u66f4\u7b80\u5355\u7684\u89e3\u51b3\u65b9\u6848\u662f\u4f7f\u7528 unix \u65f6\u95f4\u4e0e\u5fae\u79d2\u5206\u8fa8\u7387\u7684\u7ec4\u5408\uff0c\u5c06\u5176\u4e0e\u5ba2\u6237\u7aef ID \u8fde\u63a5\u8d77\u6765\uff0c\u5b83\u4e0d\u662f\u90a3\u4e48\u5b89\u5168\uff0c\u4f46\u53ef\u80fd\u5728\u5927\u591a\u6570\u73af\u5883\u4e2d\u90fd\u53ef\u4ee5\u80dc\u4efb\u3002"}),"\n",(0,n.jsxs)(t.p,{children:["The time we use as the key ",(0,n.jsx)(t.strong,{children:"time to live"}),", is called the \u201clock validity time\u201d. It is both the auto release time, and the time the client has in order to perform the operation required before another client may be able to acquire the lock again, without technically violating the mutual exclusion guarantee, which is only limited to a given window of time from the moment the lock is acquired."]}),"\n",(0,n.jsx)(t.p,{children:"key \u7684\u8fc7\u671f\u65f6\u95f4\uff0c\u79f0\u4e3a\u300c\u9501\u6709\u6548\u65f6\u95f4\u300d\u3002\u5b83\u65e2\u662f\u81ea\u52a8\u91ca\u653e\u65f6\u95f4\uff0c\u4e5f\u662f\u5ba2\u6237\u7aef\u5728\u53e6\u4e00\u4e2a\u5ba2\u6237\u7aef\u53ef\u80fd\u80fd\u591f\u518d\u6b21\u83b7\u53d6\u9501\u4e4b\u524d\u6267\u884c\u6240\u9700\u64cd\u4f5c\u7684\u65f6\u95f4\uff0c\u800c\u4e0d\u4f1a\u5728\u6280\u672f\u4e0a\u8fdd\u53cd\u4e92\u65a5\u4fdd\u8bc1\uff0c\u4e92\u65a5\u4fdd\u8bc1\u4ec5\u9650\u4e8e\u4ece\u83b7\u5f97\u9501\u7684\u90a3\u4e00\u523b\u8d77\u7684\u7ed9\u5b9a\u65f6\u95f4\u7a97\u53e3"}),"\n",(0,n.jsx)(t.p,{children:"So now we have a good way to acquire and release the lock. The system, reasoning about a non-distributed system composed of a single, always available, instance, is safe. Let\u2019s extend the concept to a distributed system where we don\u2019t have such guarantees."}),"\n",(0,n.jsx)(t.p,{children:"\u6240\u4ee5\u73b0\u5728\u6211\u4eec\u6709\u4e86\u4e00\u4e2a\u83b7\u53d6\u548c\u91ca\u653e\u9501\u7684\u597d\u65b9\u6cd5\u3002\u8be5\u7cfb\u7edf\u63a8\u7406\u7531\u4e00\u4e2a\u59cb\u7ec8\u53ef\u7528\u7684\u5355\u4e2a\u5b9e\u4f8b\u7ec4\u6210\u7684\u975e\u5206\u5e03\u5f0f\u7cfb\u7edf\u662f\u5b89\u5168\u7684\u3002\u8ba9\u6211\u4eec\u5c06\u8fd9\u4e2a\u6982\u5ff5\u6269\u5c55\u5230\u6ca1\u6709\u6b64\u7c7b\u4fdd\u8bc1\u7684\u5206\u5e03\u5f0f\u7cfb\u7edf\u3002"}),"\n",(0,n.jsx)(t.h2,{id:"the-redlock-algorithm",children:"The Redlock algorithm"}),"\n",(0,n.jsx)(t.p,{children:"In the distributed version of the algorithm we assume we have N Redis masters. Those nodes are totally independent, so we don\u2019t use replication or any other implicit coordination system. We already described how to acquire and release the lock safely in a single instance. We take for granted that the algorithm will use this method to acquire and release the lock in a single instance. In our examples we set N=5, which is a reasonable value, so we need to run 5 Redis masters on different computers or virtual machines in order to ensure that they\u2019ll fail in a mostly independent way."}),"\n",(0,n.jsx)(t.p,{children:"\u5728\u7b97\u6cd5\u7684\u5206\u5e03\u5f0f\u7248\u672c\u4e2d\uff0c\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u6709 N \u4e2a Redis master\u3002\u8fd9\u4e9b\u8282\u70b9\u662f\u5b8c\u5168\u72ec\u7acb\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u4f7f\u7528\u590d\u5236\u6216\u4efb\u4f55\u5176\u4ed6\u9690\u5f0f\u534f\u8c03\u7cfb\u7edf\u3002\u6211\u4eec\u5df2\u7ecf\u63cf\u8ff0\u4e86\u5982\u4f55\u5728\u5355\u4e2a\u5b9e\u4f8b\u4e2d\u5b89\u5168\u5730\u83b7\u53d6\u548c\u91ca\u653e\u9501\u3002\u6211\u4eec\u7406\u6240\u5f53\u7136\u5730\u8ba4\u4e3a\u7b97\u6cd5\u4f1a\u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\u5728\u5355\u4e2a\u5b9e\u4f8b\u4e2d\u83b7\u53d6\u548c\u91ca\u653e\u9501\u3002\u5728\u6211\u4eec\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u8bbe\u7f6e N=5\uff0c\u8fd9\u662f\u4e00\u4e2a\u5408\u7406\u7684\u503c\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5728\u4e0d\u540c\u7684\u8ba1\u7b97\u673a\u6216\u865a\u62df\u673a\u4e0a\u8fd0\u884c 5 \u4e2a Redis \u4e3b\u670d\u52a1\u5668\uff0c\u4ee5\u786e\u4fdd\u5b83\u4eec\u4ee5\u51e0\u4e4e\u72ec\u7acb\u7684\u65b9\u5f0f\u53d1\u751f\u6545\u969c\u3002"}),"\n",(0,n.jsx)(t.p,{children:"In order to acquire the lock, the client performs the following operations:"}),"\n",(0,n.jsx)(t.p,{children:"\u4e3a\u4e86\u83b7\u53d6\u9501\uff0c\u5ba2\u6237\u7aef\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c\uff1a"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"It gets the current time in milliseconds."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"It tries to acquire the lock in all the N instances sequentially, using the same key name and random value in all the instances. During step 2, when setting the lock in each instance, the client uses a timeout which is small compared to the total lock auto-release time in order to acquire it. For example if the auto-release time is 10 seconds, the timeout could be in the ~ 5-50 milliseconds range. This prevents the client from remaining blocked for a long time trying to talk with a Redis node which is down: if an instance is not available, we should try to talk with the next instance ASAP."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The client computes how much time elapsed in order to acquire the lock, by subtracting from the current time the timestamp obtained in step 1. If and only if the client was able to acquire the lock in the majority of the instances (at least 3), and the total time elapsed to acquire the lock is less than lock validity time, the lock is considered to be acquired."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"If the lock was acquired, its validity time is considered to be the initial validity time minus the time elapsed, as computed in step 3."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"If the client failed to acquire the lock for some reason (either it was not able to lock N/2+1 instances or the validity time is negative), it will try to unlock all the instances (even the instances it believed it was not able to lock)."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u5b83\u4ee5\u6beb\u79d2\u4e3a\u5355\u4f4d\u83b7\u53d6\u5f53\u524d\u65f6\u95f4\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u5b83\u5c1d\u8bd5\u987a\u5e8f\u83b7\u53d6\u6240\u6709 N \u4e2a\u5b9e\u4f8b\u4e2d\u7684\u9501\uff0c\u5728\u6240\u6709\u5b9e\u4f8b\u4e2d\u4f7f\u7528\u76f8\u540c\u7684\u952e\u540d\u548c\u968f\u673a\u503c\u3002\u5728\u6b65\u9aa4 2 \u4e2d\uff0c\u5f53\u5728\u6bcf\u4e2a\u5b9e\u4f8b\u4e2d\u8bbe\u7f6e\u9501\u65f6\uff0c\u5ba2\u6237\u7aef\u4f7f\u7528\u4e00\u4e2a\u4e0e\u9501\u81ea\u52a8\u91ca\u653e\u603b\u65f6\u95f4\u76f8\u6bd4\u8f83\u5c0f\u7684 timeout \u6765\u83b7\u53d6\u5b83\uff08\u9632\u6b62\u5355\u70b9\u963b\u585e\uff09\u3002\u4f8b\u5982\uff0c\u5982\u679c\u9501\u7684\u81ea\u52a8\u91ca\u653e\u65f6\u95f4\u4e3a 10 \u79d2\uff0c\u5219 timeout \u53ef\u80fd\u5728 ~ 5-50 \u6beb\u79d2\u8303\u56f4\u5185\u3002\u8fd9\u53ef\u4ee5\u9632\u6b62\u5ba2\u6237\u7aef\u5728\u5c1d\u8bd5\u4e0e\u5df2\u5173\u95ed\u7684 Redis \u8282\u70b9\u901a\u4fe1\u65f6\u957f\u65f6\u95f4\u4fdd\u6301\u963b\u585e\uff1a\u5982\u679c\u4e00\u4e2a\u5b9e\u4f8b\u4e0d\u53ef\u7528\uff0c\u6211\u4eec\u5e94\u8be5\u5c3d\u5feb\u5c1d\u8bd5\u4e0e\u4e0b\u4e00\u4e2a\u5b9e\u4f8b\u901a\u4fe1\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u5ba2\u6237\u7aef\u901a\u8fc7\u4ece\u5f53\u524d\u65f6\u95f4\u4e2d\u51cf\u53bb\u6b65\u9aa4 1 \u4e2d\u83b7\u5f97\u7684\u65f6\u95f4\u6233\u6765\u8ba1\u7b97\u83b7\u53d6\u9501\u6240\u7528\u7684\u65f6\u95f4\u3002\u5f53\u4e14\u4ec5\u5f53\u5ba2\u6237\u7aef\u80fd\u591f\u5728\u5927\u591a\u6570\u5b9e\u4f8b\u4e2d\u83b7\u53d6\u9501\uff08\u81f3\u5c11 3 \u4e2a\uff09 \uff0c\u4e14\u83b7\u53d6\u9501\u7684\u603b\u65f6\u95f4\u5c0f\u4e8e\u9501\u7684\u6709\u6548\u65f6\u95f4\uff0c\u5219\u8ba4\u4e3a\u9501\u5df2\u88ab\u83b7\u53d6\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u5982\u679c\u83b7\u5f97\u4e86\u9501\uff0c\u5219\u5176\u6709\u6548\u65f6\u95f4\u88ab\u8ba4\u4e3a\u662f\u521d\u59cb\u6709\u6548\u65f6\u95f4\u51cf\u53bb\u7ecf\u8fc7\u7684\u65f6\u95f4\uff0c\u5982\u6b65\u9aa4 3 \u4e2d\u8ba1\u7b97\u7684\u90a3\u6837\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u5982\u679c\u5ba2\u6237\u7aef\u7531\u4e8e\u67d0\u79cd\u539f\u56e0\u672a\u80fd\u83b7\u5f97\u9501\uff08\u5b83\u65e0\u6cd5\u9501\u5b9a N/2+1 \u4e2a\u5b9e\u4f8b\u6216\u6709\u6548\u65f6\u95f4\u4e3a\u8d1f\u6570\uff09\uff0c\u5b83\u5c06\u5c1d\u8bd5\u89e3\u9501\u6240\u6709\u5b9e\u4f8b\uff08\u751a\u81f3\u662f\u5b83\u8ba4\u4e3a\u65e0\u6cd5\u9501\u5b9a\u7684\u5b9e\u4f8b\uff09\u3002"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"is-the-algorithm-asynchronous",children:"Is the algorithm asynchronous?"}),"\n",(0,n.jsx)(t.p,{children:"The algorithm relies on the assumption that while there is no synchronized clock across the processes, still the local time in every process flows approximately at the same rate, with an error which is small compared to the auto-release time of the lock. This assumption closely resembles a real-world computer: every computer has a local clock and we can usually rely on different computers to have a clock drift which is small."}),"\n",(0,n.jsx)(t.p,{children:"\u8be5\u7b97\u6cd5\u4f9d\u8d56\u4e8e\u8fd9\u6837\u4e00\u4e2a\u5047\u8bbe\uff1a\u867d\u7136\u8fdb\u7a0b\u4e4b\u95f4\u6ca1\u6709\u540c\u6b65\u65f6\u949f\uff0c\u4f46\u6bcf\u4e2a\u8fdb\u7a0b\u4e2d\u7684\u672c\u5730\u65f6\u95f4\u4ecd\u7136\u4ee5\u5927\u81f4\u76f8\u540c\u7684\u901f\u7387\u6d41\u52a8\uff0c\u4e0e\u9501\u7684\u81ea\u52a8\u91ca\u653e\u65f6\u95f4\u76f8\u6bd4\uff0c\u8bef\u5dee\u5f88\u5c0f\u3002\u8fd9\u4e2a\u5047\u8bbe\u975e\u5e38\u7c7b\u4f3c\u4e8e\u73b0\u5b9e\u4e16\u754c\u7684\u8ba1\u7b97\u673a\uff1a\u6bcf\u53f0\u8ba1\u7b97\u673a\u90fd\u6709\u4e00\u4e2a\u672c\u5730\u65f6\u949f\uff0c\u6211\u4eec\u901a\u5e38\u53ef\u4ee5\u4f9d\u9760\u4e0d\u540c\u7684\u8ba1\u7b97\u673a\u6765\u83b7\u5f97\u5f88\u5c0f\u7684\u65f6\u949f\u6f02\u79fb\u3002"}),"\n",(0,n.jsx)(t.p,{children:"At this point we need to better specify our mutual exclusion rule: it is guaranteed only as long as the client holding the lock will terminate its work within the lock validity time (as obtained in step 3), minus some time (just a few milliseconds in order to compensate for clock drift between processes)."}),"\n",(0,n.jsx)(t.p,{children:"\u6b64\u65f6\u6211\u4eec\u9700\u8981\u66f4\u597d\u5730\u6307\u5b9a\u6211\u4eec\u7684\u4e92\u65a5\u89c4\u5219\uff1a\u53ea\u6709\u6301\u6709\u9501\u7684\u5ba2\u6237\u7aef\u4f1a\u5728\u9501\u7684\u6709\u6548\u671f\u5185\uff08\u5982\u6b65\u9aa4 3 \u4e2d\u83b7\u5f97\uff09\u5185\u7ec8\u6b62\u5176\u5de5\u4f5c\uff0c\u51cf\u53bb\u4e00\u4e9b\u65f6\u95f4\uff08\u4ec5\u51e0\u6beb\u79d2\uff0c\u624d\u80fd\u4fdd\u8bc1\u4e92\u65a5\u89c4\u5219\u4e3a\u4e86\u8865\u507f\u8fdb\u7a0b\u4e4b\u95f4\u7684\u65f6\u949f\u6f02\u79fb\uff09\u3002"}),"\n",(0,n.jsxs)(t.p,{children:["For more information about similar systems requiring a bound ",(0,n.jsx)(t.em,{children:"clock drift"}),", this paper is an interesting reference: ",(0,n.jsx)(t.a,{href:"http://dl.acm.org/citation.cfm?id=74870",children:"Leases: an efficient fault-tolerant mechanism for distributed file cache consistency"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"retry-on-failure",children:"Retry on failure"}),"\n",(0,n.jsx)(t.p,{children:"When a client is unable to acquire the lock, it should try again after a random delay in order to try to desynchronize multiple clients trying to acquire the lock for the same resource at the same time (this may result in a split brain condition where nobody wins). Also the faster a client tries to acquire the lock in the majority of Redis instances, the smaller the window for a split brain condition (and the need for a retry), so ideally the client should try to send the SET commands to the N instances at the same time using multiplexing."}),"\n",(0,n.jsx)(t.p,{children:"\u5f53\u5ba2\u6237\u7aef\u65e0\u6cd5\u83b7\u53d6\u9501\u65f6\uff0c\u5b83\u5e94\u8be5\u5728\u968f\u673a\u5ef6\u8fdf\u540e\u518d\u6b21\u5c1d\u8bd5\uff0c\u8fd9\u662f\u4e3a\u4e86\u5c3d\u53ef\u80fd\u540c\u6b65\u591a\u4e2a\u5ba2\u6237\u7aef\u540c\u65f6\u5c1d\u8bd5\u83b7\u53d6\u540c\u4e00\u8d44\u6e90\u7684\u9501\uff08\u8fd9\u53ef\u80fd\u4f1a\u5bfc\u81f4\u6ca1\u6709\u4eba\u83b7\u80dc\u7684\u8111\u88c2\u72b6\u6001\uff09\u3002\u6b64\u5916\uff0c\u5ba2\u6237\u7aef\u5728\u5927\u591a\u6570 Redis \u5b9e\u4f8b\u4e2d\u5c1d\u8bd5\u83b7\u53d6\u9501\u7684\u901f\u5ea6\u8d8a\u5feb\uff0c\u88c2\u8111\u6761\u4ef6\u7684\u7a97\u53e3\u5c31\u8d8a\u5c0f\uff08\u4ee5\u53ca\u91cd\u8bd5\u7684\u9700\u8981\uff09\uff0c\u56e0\u6b64\u7406\u60f3\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u5e94\u8be5\u5c1d\u8bd5\u5c06 SET \u547d\u4ee4\u53d1\u9001\u5230 N \u4e2a\u5b9e\u4f8b\u540c\u65f6\u4f7f\u7528\u591a\u8def\u590d\u7528\u3002"}),"\n",(0,n.jsx)(t.p,{children:"It is worth stressing how important it is for clients that fail to acquire the majority of locks, to release the (partially) acquired locks ASAP, so that there is no need to wait for key expiry in order for the lock to be acquired again (however if a network partition happens and the client is no longer able to communicate with the Redis instances, there is an availability penalty to pay as it waits for key expiration)."}),"\n",(0,n.jsx)(t.p,{children:"\u503c\u5f97\u5f3a\u8c03\u7684\u662f\uff0c\u5bf9\u4e8e\u672a\u80fd\u83b7\u5f97\u5927\u90e8\u5206\u9501\u7684\u5ba2\u6237\u7aef\u6765\u8bf4\uff0c\u5c3d\u5feb\u91ca\u653e\uff08\u90e8\u5206\uff09\u83b7\u5f97\u7684\u9501\u662f\u591a\u4e48\u91cd\u8981\uff0c\u8fd9\u6837\u5c31\u65e0\u9700\u7b49\u5f85\u5bc6\u94a5\u5230\u671f\u624d\u80fd\u518d\u6b21\u83b7\u5f97\u9501\uff08\u4f46\u662f\uff0c\u5982\u679c\u53d1\u751f\u7f51\u7edc\u5206\u533a\u5e76\u4e14\u5ba2\u6237\u7aef\u4e0d\u518d\u80fd\u591f\u4e0e Redis \u5b9e\u4f8b\u901a\u4fe1\uff0c\u5219\u9700\u8981\u627f\u62c5\u300c\u7b49\u5f85\u5bc6\u94a5\u5230\u671f\u300d\u7684\u6027\u80fd\u635f\u5931\uff09\u3002"}),"\n",(0,n.jsx)(t.h2,{id:"releasing-the-lock",children:"Releasing the lock"}),"\n",(0,n.jsx)(t.p,{children:"Releasing the lock is simple and involves just releasing the lock in all instances, whether or not the client believes it was able to successfully lock a given instance."}),"\n",(0,n.jsx)(t.p,{children:"\u91ca\u653e\u9501\u5f88\u7b80\u5355\uff0c\u53ea\u6d89\u53ca\u5728\u6240\u6709\u5b9e\u4f8b\u4e2d\u91ca\u653e\u9501\uff0c\u65e0\u8bba\u5ba2\u6237\u7aef\u662f\u5426\u76f8\u4fe1\u5b83\u80fd\u591f\u6210\u529f\u9501\u5b9a\u7ed9\u5b9a\u5b9e\u4f8b\u3002"}),"\n",(0,n.jsx)(t.h2,{id:"safety-arguments",children:"Safety arguments"}),"\n",(0,n.jsx)(t.p,{children:"Is the algorithm safe? We can try to understand what happens in different scenarios."}),"\n",(0,n.jsx)(t.p,{children:"\u7b97\u6cd5\u5b89\u5168\u5417\uff1f\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u4e86\u89e3\u5728\u4e0d\u540c\u60c5\u51b5\u4e0b\u4f1a\u53d1\u751f\u4ec0\u4e48\u3002"}),"\n",(0,n.jsxs)(t.p,{children:["To start let\u2019s assume that a client is able to acquire the lock in the majority of instances. All the instances will contain a key with the same ",(0,n.jsx)(t.strong,{children:"time to live"}),". However, the key was set at different times, so the keys will also expire at different times. But if the first key was set at worst at time T1 (the time we sample before contacting the first server) and the last key was set at worst at time T2 (the time we obtained the reply from the last server), we are sure that the first key to expire in the set will exist for at least ",(0,n.jsx)(t.code,{children:"MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT"}),"(TTL Time To Live). All the other keys will expire later, so we are sure that the keys will be simultaneously set for at least this time."]}),"\n",(0,n.jsxs)(t.p,{children:["\u9996\u5148\u8ba9\u6211\u4eec\u5047\u8bbe\u5ba2\u6237\u7aef\u80fd\u591f\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u83b7\u53d6\u9501\u3002\u6240\u6709\u5b9e\u4f8b\u90fd\u5c06\u5305\u542b\u4e00\u4e2a\u5177\u6709\u76f8\u540c\u751f\u5b58\u65f6\u95f4\u7684 key\u3002\u4f46\u662f\uff0ckey \u662f\u5728\u4e0d\u540c\u7684\u65f6\u95f4\u8bbe\u7f6e\u7684\uff0c\u6240\u4ee5 key \u4e5f\u4f1a\u5728\u4e0d\u540c\u7684\u65f6\u95f4\u8fc7\u671f\u3002\u4f46\u662f\u5982\u679c\u7b2c\u4e00\u4e2a\u5bc6\u94a5\u5728\u65f6\u95f4 T1\uff08\u6211\u4eec\u5728\u8054\u7cfb\u7b2c\u4e00\u53f0\u670d\u52a1\u5668\u4e4b\u524d\u91c7\u6837\u7684\u65f6\u95f4\uff09\u8bbe\u7f6e\u4e3a\u6700\u5dee\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u5bc6\u94a5\u5728\u65f6\u95f4 T2\uff08\u6211\u4eec\u4ece\u6700\u540e\u4e00\u4e2a\u670d\u52a1\u5668\u83b7\u5f97\u56de\u590d\u7684\u65f6\u95f4\uff09\u8bbe\u7f6e\u4e3a\u6700\u5dee\uff0c\u6211\u4eec\u786e\u5b9a\u96c6\u5408\u4e2d\u7b2c\u4e00\u4e2a\u8fc7\u671f\u7684\u5bc6\u94a5\u5c06\u81f3\u5c11\u5b58\u5728 ",(0,n.jsx)(t.code,{children:"MIN_VALIDITY = TTL-(T2-T1)-CLOCK_DRIFT"}),"\u3002\u6240\u6709\u5176\u4ed6\u5bc6\u94a5\u90fd\u5c06\u5728\u7a0d\u540e\u8fc7\u671f\uff0c\u56e0\u6b64\u6211\u4eec\u786e\u4fe1\u8fd9\u4e9b key \u5c06\u81f3\u5c11\u5728\u6bb5\u65f6\u95f4\u5185\u540c\u65f6\u8bbe\u7f6e\u3002"]}),"\n",(0,n.jsx)(t.p,{children:"During the time that the majority of keys are set, another client will not be able to acquire the lock, since N/2+1 SET NX operations can\u2019t succeed if N/2+1 keys already exist. So if a lock was acquired, it is not possible to re-acquire it at the same time (violating the mutual exclusion property)."}),"\n",(0,n.jsxs)(t.p,{children:["\u5728\u8bbe\u7f6e\u5927\u90e8\u5206\u952e\u7684\u65f6\u95f4\u5185\uff0c\u53e6\u4e00\u4e2a\u5ba2\u6237\u7aef\u5c06\u65e0\u6cd5\u83b7\u53d6\u9501\uff0c\u56e0\u4e3a\u5982\u679c N/2+1 \u4e2a\u952e\u5df2\u7ecf\u5b58\u5728\uff0c\u5219 N/2+1 \u4e2a ",(0,n.jsx)(t.code,{children:"SET NX"})," \u64cd\u4f5c\u5c06\u65e0\u6cd5\u6210\u529f\u3002\u6240\u4ee5\u5982\u679c\u83b7\u5f97\u4e86\u4e00\u4e2a\u9501\uff0c\u5c31\u4e0d\u53ef\u80fd\u540c\u65f6\u91cd\u65b0\u83b7\u5f97\u5b83\uff08\u8fdd\u53cd\u4e92\u65a5\u5c5e\u6027\uff09\u3002"]}),"\n",(0,n.jsx)(t.p,{children:"However we want to also make sure that multiple clients trying to acquire the lock at the same time can\u2019t simultaneously succeed."}),"\n",(0,n.jsx)(t.p,{children:"\u4f46\u662f\uff0c\u6211\u4eec\u8fd8\u60f3\u786e\u4fdd\u591a\u4e2a\u5ba2\u6237\u7aef\u540c\u65f6\u5c1d\u8bd5\u83b7\u53d6\u9501\u4e0d\u80fd\u540c\u65f6\u6210\u529f\u3002"}),"\n",(0,n.jsxs)(t.p,{children:["If a client locked the majority of instances using a time near, or greater, than the lock maximum validity time (the TTL we use for SET basically), it will consider the lock invalid and will unlock the instances, so we only need to consider the case where a client was able to lock the majority of instances in a time which is less than the validity time. In this case for the argument already expressed above, for ",(0,n.jsx)(t.code,{children:"MIN_VALIDITY"}),' no client should be able to re-acquire the lock. So multiple clients will be able to lock N/2+1 instances at the same time (with "time" being the end of Step 2) only when the time to lock the majority was greater than the TTL time, making the lock invalid.']}),"\n",(0,n.jsx)(t.p,{children:"\u5982\u679c\u5ba2\u6237\u7aef\u4f7f\u7528\u63a5\u8fd1\u6216\u5927\u4e8e\u9501\u6700\u5927\u6709\u6548\u65f6\u95f4\uff08\u57fa\u672c\u4e0a\u5c31\u662f\u6211\u4eec\u7ed9 SET \u64cd\u4f5c\u8bbe\u7f6e\u7684\u7684 TTL\uff09\u7684\u65f6\u95f4\u9501\u5b9a\u5927\u591a\u6570\u5b9e\u4f8b\uff0c\u5b83\u5c06\u8ba4\u4e3a\u9501\u65e0\u6548\u5e76\u89e3\u9501\u5b9e\u4f8b\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u8003\u8651\u5ba2\u6237\u7aef\u80fd\u591f\u5728\u5c0f\u4e8e\u6709\u6548\u65f6\u95f4\u7684\u65f6\u95f4\u5185\u9501\u5b9a\u5927\u591a\u6570\u5b9e\u4f8b\u7684\u60c5\u51b5\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5bf9\u4e8e\u4e0a\u9762\u5df2\u7ecf\u8868\u8fbe\u7684\u53c2\u6570\uff0c\u5bf9\u4e8e\u201cMIN_VALIDITY\u201d\uff0c\u6ca1\u6709\u5ba2\u6237\u7aef\u5e94\u8be5\u80fd\u591f\u91cd\u65b0\u83b7\u53d6\u9501\u3002\u56e0\u6b64\uff0c\u53ea\u6709\u5f53\u9501\u5b9a\u591a\u6570\u7684\u65f6\u95f4\u5927\u4e8e TTL \u65f6\u95f4\u65f6\uff0c\u591a\u4e2a\u5ba2\u6237\u7aef\u624d\u80fd\u540c\u65f6\u9501\u5b9a N/2+1 \u4e2a\u5b9e\u4f8b\uff08\u201c\u65f6\u95f4\u201d\u662f\u6b65\u9aa4 2 \u7684\u7ed3\u675f\uff09\uff0c\u5982\u524d\u6587\u6240\u8ff0\uff0c\u9501\u5b9a\u4f1a\u88ab\u5224\u5b9a\u4e3a\u65e0\u6548\u3002"}),"\n",(0,n.jsx)(t.p,{children:"Are you able to provide a formal proof of safety, point to existing algorithms that are similar, or find a bug? That would be greatly appreciated."}),"\n",(0,n.jsx)(t.p,{children:"\u60a8\u662f\u5426\u80fd\u591f\u63d0\u4f9b\u6b63\u5f0f\u7684\u5b89\u5168\u8bc1\u660e\u3001\u6307\u51fa\u73b0\u6709\u7684\u76f8\u4f3c\u7b97\u6cd5\u6216\u53d1\u73b0\u9519\u8bef\uff1f\u90a3\u5c06\u4e0d\u80dc\u611f\u6fc0\u3002"}),"\n",(0,n.jsx)(t.h2,{id:"liveness-arguments",children:"Liveness arguments"}),"\n",(0,n.jsx)(t.p,{children:"The system liveness is based on three main features:"}),"\n",(0,n.jsx)(t.p,{children:"\u7cfb\u7edf\u6d3b\u8dc3\u5ea6\u57fa\u4e8e\u4e09\u4e2a\u4e3b\u8981\u7279\u5f81\uff1a"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The auto release of the lock (since keys expire): eventually keys are available again to be locked."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The fact that clients, usually, will cooperate removing the locks when the lock was not acquired, or when the lock was acquired and the work terminated, making it likely that we don\u2019t have to wait for keys to expire to re-acquire the lock."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The fact that when a client needs to retry a lock, it waits a time which is comparably greater than the time needed to acquire the majority of locks, in order to probabilistically make split brain conditions during resource contention unlikely."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u9501\u7684\u81ea\u52a8\u91ca\u653e\uff08\u56e0\u4e3a key \u8fc7\u671f\uff09\uff1a\u6700\u7ec8 key \u53ef\u4ee5\u518d\u6b21\u88ab\u9501\u5b9a\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u4e8b\u5b9e\u4e0a\uff0c\u5ba2\u6237\u7aef\u901a\u5e38\u4f1a\u5728\u672a\u83b7\u53d6\u9501\u6216\u83b7\u53d6\u9501\u4f46\u5de5\u4f5c\u7ec8\u6b62\u65f6\u5408\u4f5c\u79fb\u9664\u9501\uff0c\u8fd9\u4f7f\u5f97\u6211\u4eec\u53ef\u80fd\u4e0d\u5fc5\u7b49\u5f85\u5bc6\u94a5\u8fc7\u671f\u6765\u91cd\u65b0\u83b7\u53d6\u9501\u3002"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"\u4e8b\u5b9e\u4e0a\uff0c\u5f53\u5ba2\u6237\u7aef\u9700\u8981\u91cd\u8bd5\u9501\u65f6\uff0c\u5b83\u7b49\u5f85\u7684\u65f6\u95f4\u6bd4\u83b7\u53d6\u5927\u591a\u6570\u9501\u6240\u9700\u7684\u65f6\u95f4\u8981\u957f\u5f97\u591a\uff0c\u4ee5\u4fbf\u5728\u8d44\u6e90\u4e89\u7528\u671f\u95f4\u4e0d\u592a\u53ef\u80fd\u51fa\u73b0\u8111\u88c2\u60c5\u51b5\u3002"}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"However, we pay an availability penalty equal to TTL time on network partitions, so if there are continuous partitions, we can pay this penalty indefinitely. This happens every time a client acquires a lock and gets partitioned away before being able to remove the lock."}),"\n",(0,n.jsx)(t.p,{children:"Basically if there are infinite continuous network partitions, the system may become not available for an infinite amount of time."}),"\n",(0,n.jsx)(t.p,{children:"\u57fa\u672c\u4e0a\uff0c\u5982\u679c\u6709\u65e0\u9650\u8fde\u7eed\u7684\u7f51\u7edc\u5206\u533a\uff0c\u7cfb\u7edf\u53ef\u80fd\u4f1a\u5728\u65e0\u9650\u957f\u7684\u65f6\u95f4\u5185\u53d8\u5f97\u4e0d\u53ef\u7528\u3002"}),"\n",(0,n.jsx)(t.h2,{id:"performance-crash-recovery-and-fsync",children:"Performance, crash-recovery and fsync"}),"\n",(0,n.jsx)(t.p,{children:"Many users using Redis as a lock server need high performance in terms of both latency to acquire and release a lock, and number of acquire / release operations that it is possible to perform per second. In order to meet this requirement, the strategy to talk with the N Redis servers to reduce latency is definitely multiplexing (or poor man's multiplexing, which is, putting the socket in non-blocking mode, send all the commands, and read all the commands later, assuming that the RTT(Round-trip delay \u5f80\u8fd4\u5ef6\u8bef) between the client and each instance is similar)."}),"\n",(0,n.jsx)(t.p,{children:"\u8bb8\u591a\u4f7f\u7528 Redis \u4f5c\u4e3a\u9501\u670d\u52a1\u5668\u7684\u7528\u6237\u5728\u83b7\u53d6\u548c\u91ca\u653e\u9501\u7684\u5ef6\u8fdf\u4ee5\u53ca\u6bcf\u79d2\u53ef\u4ee5\u6267\u884c\u7684\u83b7\u53d6/\u91ca\u653e\u64cd\u4f5c\u7684\u6570\u91cf\u65b9\u9762\u90fd\u9700\u8981\u9ad8\u6027\u80fd\u3002\u4e3a\u4e86\u6ee1\u8db3\u8fd9\u4e2a\u9700\u6c42\uff0c\u4e0e N \u53f0 Redis \u670d\u52a1\u5668\u5bf9\u8bdd\u4ee5\u51cf\u5c11\u5ef6\u8fdf\u7684\u7b56\u7565\u80af\u5b9a\u662f\u591a\u8def\u590d\u7528\uff08\u6216\u8005\u8bf4\u7a77\u4eba\u7684\u591a\u8def\u590d\u7528\uff0c\u4e5f\u5c31\u662f\u5c06 socket \u7f6e\u4e8e\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u53d1\u9001\u6240\u6709\u547d\u4ee4\uff0c\u7a0d\u540e\u8bfb\u53d6\u6240\u6709\u547d\u4ee4\uff0c\u5047\u8bbe\u5ba2\u6237\u7aef\u548c\u6bcf\u4e2a\u5b9e\u4f8b\u4e4b\u95f4\u7684 RTT \u662f\u76f8\u4f3c\u7684\uff09\u3002"}),"\n",(0,n.jsx)(t.p,{children:"However there is another consideration to do about persistence if we want to target a crash-recovery system model."}),"\n",(0,n.jsx)(t.p,{children:"\u7136\u800c\uff0c\u5982\u679c\u6211\u4eec\u60f3\u8981\u9488\u5bf9\u5d29\u6e83\u6062\u590d\u7cfb\u7edf\u6a21\u578b\uff0c\u8fd8\u6709\u53e6\u4e00\u4e2a\u5173\u4e8e\u6301\u4e45\u6027\u7684\u8003\u8651\u3002"}),"\n",(0,n.jsx)(t.p,{children:"Basically to see the problem here, let\u2019s assume we configure Redis without persistence at all. A client acquires the lock in 3 of 5 instances. One of the instances where the client was able to acquire the lock is restarted, at this point there are again 3 instances that we can lock for the same resource, and another client can lock it again, violating the safety property of exclusivity of lock."}),"\n",(0,n.jsx)(t.p,{children:"\u57fa\u672c\u4e0a\u770b\u8fd9\u91cc\u7684\u95ee\u9898\uff0c\u8ba9\u6211\u4eec\u5047\u8bbe\u6211\u4eec\u914d\u7f6e Redis \u65f6\u5b8c\u5168\u6ca1\u6709\u6301\u4e45\u5316\u3002\u5ba2\u6237\u7aef\u5728 5 \u4e2a\u5b9e\u4f8b\u4e2d\u7684 3 \u4e2a\u4e2d\u83b7\u5f97\u4e86\u9501\u3002\u5176\u4e2d\u4e00\u4e2a\u5ba2\u6237\u7aef\u80fd\u591f\u83b7\u5f97\u9501\u7684\u5b9e\u4f8b\u88ab\u91cd\u542f\uff0c\u6b64\u65f6\u6211\u4eec\u53c8\u53ef\u4ee5\u4e3a\u540c\u4e00\u4e2a\u8d44\u6e90\u9501\u5b9a 3 \u4e2a\u5b9e\u4f8b\uff0c\u53e6\u4e00\u4e2a\u5ba2\u6237\u7aef\u53ef\u4ee5\u518d\u6b21\u9501\u5b9a\u5b83\uff0c\u8fdd\u53cd\u4e86\u9501\u7684\u6392\u4ed6\u6027\u7684\u5b89\u5168\u5c5e\u6027\u3002"}),"\n",(0,n.jsx)(t.p,{children:"If we enable AOF persistence, things will improve quite a bit. For example we can upgrade a server by sending SHUTDOWN and restarting it. Because Redis expires are semantically implemented so that virtually the time still elapses when the server is off, all our requirements are fine. However everything is fine as long as it is a clean shutdown. What about a power outage? If Redis is configured, as by default, to fsync on disk every second, it is possible that after a restart our key is missing. In theory, if we want to guarantee the lock safety in the face of any kind of instance restart, we need to enable fsync=always in the persistence setting. This in turn will totally ruin performances to the same level of CP systems that are traditionally used to implement distributed locks in a safe way."}),"\n",(0,n.jsx)(t.p,{children:"\u5982\u679c\u6211\u4eec\u542f\u7528 AOF \u6301\u4e45\u6027\uff0c\u4e8b\u60c5\u4f1a\u6539\u5584\u5f88\u591a\u3002\u4f8b\u5982\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u53d1\u9001 SHUTDOWN \u5e76\u91cd\u65b0\u542f\u52a8\u5b83\u6765\u5347\u7ea7\u670d\u52a1\u5668\u3002\u56e0\u4e3a Redis \u8fc7\u671f\u662f\u5728\u8bed\u4e49\u4e0a\u5b9e\u73b0\u7684\uff0c\u6240\u4ee5\u5f53\u670d\u52a1\u5668\u5173\u95ed\u65f6\uff0c\u5b9e\u9645\u4e0a\u65f6\u95f4\u4ecd\u7136\u8fc7\u53bb\uff0c\u6211\u4eec\u6240\u6709\u7684\u8981\u6c42\u90fd\u5f88\u597d\u3002\u4f46\u662f\uff0c\u53ea\u8981\u5b83\u662f\u5e72\u51c0\u7684\u5173\u95ed\uff0c\u4e00\u5207\u90fd\u5f88\u597d\u3002\u505c\u7535\u600e\u4e48\u529e\uff1f\u5982\u679c Redis \u9ed8\u8ba4\u914d\u7f6e\u4e3a\u6bcf\u79d2\u5728\u78c1\u76d8\u4e0a fsync \u4e00\u6b21\uff0c\u90a3\u4e48\u91cd\u542f\u540e\u6211\u4eec\u7684 key \u53ef\u80fd\u4f1a\u4e22\u5931\u3002\u7406\u8bba\u4e0a\uff0c\u5982\u679c\u6211\u4eec\u60f3\u5728\u4efb\u4f55\u7c7b\u578b\u7684\u5b9e\u4f8b\u91cd\u542f\u65f6\u4fdd\u8bc1\u9501\u7684\u5b89\u5168\u6027\uff0c\u6211\u4eec\u9700\u8981\u5728\u6301\u4e45\u5316\u8bbe\u7f6e\u4e2d\u542f\u7528 fsync=always\u3002\u8fd9\u53cd\u8fc7\u6765\u53c8\u4f1a\u5b8c\u5168\u7834\u574f\u4e0e\u4f20\u7edf\u4e0a\u7528\u4e8e\u4ee5\u5b89\u5168\u65b9\u5f0f\u5b9e\u73b0\u5206\u5e03\u5f0f\u9501\u7684 CP \u7cfb\u7edf\u76f8\u540c\u7ea7\u522b\u7684\u6027\u80fd\u3002"}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Consistency_model",children:"Consistency"}),"\nEvery read receives the most recent write or an error."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Availability",children:"Availability"}),"\nEvery request receives a (non-error) response, without the guarantee that it contains the most recent write."]}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Network_partitioning",children:"Partition tolerance"}),"\nThe system continues to operate despite(\u5c3d\u7ba1) an arbitrary number of messages being dropped (or delayed) by the network between nodes."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["However things are better than what they look like at a first glance. Basically the algorithm safety is retained as long as when an instance restarts after a crash, it no longer participates to any ",(0,n.jsx)(t.strong,{children:"currently active"})," lock, so that the set of currently active locks when the instance restarts, were all obtained by locking instances other than the one which is rejoining the system."]}),"\n",(0,n.jsxs)(t.p,{children:["\u7136\u800c\uff0c\u4e8b\u60c5\u6bd4\u4e4d\u770b\u4e4b\u4e0b\u8981\u597d\u3002\u57fa\u672c\u4e0a\u7b97\u6cd5\u5b89\u5168\u6027\u53ea\u8981\u5728\u5b9e\u4f8b\u5d29\u6e83\u540e\u91cd\u542f\u65f6\uff0c\u4e0d\u518d\u53c2\u4e0e\u4efb\u4f55",(0,n.jsx)(t.strong,{children:"\u5f53\u524d\u6d3b\u52a8\u7684"}),"\u9501\uff0c\u56e0\u6b64\u5b9e\u4f8b\u91cd\u542f\u65f6\u5f53\u524d\u6d3b\u52a8\u7684\u9501\u96c6\u5408\uff0c\u90fd\u662f\u901a\u8fc7\u9501\u5b9a\u5b9e\u4f8b\u83b7\u5f97\u7684\u9664\u4e86\u91cd\u65b0\u52a0\u5165\u7cfb\u7edf\u7684\u90a3\u4e2a\u3002"]}),"\n",(0,n.jsx)(t.p,{children:"To guarantee this we just need to make an instance, after a crash, unavailable for at least a bit more than the max TTL we use, which is, the time needed for all the keys about the locks that existed when the instance crashed, to become invalid and be automatically released."}),"\n",(0,n.jsx)(t.p,{children:"\u4e3a\u4e86\u4fdd\u8bc1\u8fd9\u4e00\u70b9\uff0c\u6211\u4eec\u53ea\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u5728\u5d29\u6e83\u4e4b\u540e\uff0c\u81f3\u5c11\u6bd4\u6211\u4eec\u4f7f\u7528\u7684\u6700\u5927 TTL \u591a\u4e00\u70b9\u4e4b\u540e\u518d\u53d8\u5f97\u53ef\u7528\uff0c\u5373\u6240\u6709\u5173\u4e8e\u9501\u7684\u952e\u6240\u9700\u7684\u65f6\u95f4\u5b9e\u4f8b\u5d29\u6e83\u65f6\u5b58\u5728\u7684\uff0c\u53d8\u4e3a\u65e0\u6548\u5e76\u81ea\u52a8\u91ca\u653e\u3002"}),"\n",(0,n.jsxs)(t.p,{children:["Using ",(0,n.jsx)(t.em,{children:"delayed restarts"})," it is basically possible to achieve safety even without any kind of Redis persistence available, however note that this may translate into an availability penalty. For example if a majority of instances crash, the system will become globally unavailable for TTL (here globally means that no resource at all will be lockable during this time)."]}),"\n",(0,n.jsxs)(t.p,{children:["\u4f7f\u7528 ",(0,n.jsx)(t.em,{children:"delayed restarts"})," \u57fa\u672c\u4e0a\u53ef\u4ee5\u5b9e\u73b0\u5b89\u5168\uff0c\u5373\u4f7f\u6ca1\u6709\u4efb\u4f55\u53ef\u7528\u7684 Redis \u6301\u4e45\u6027\uff0c\u4f46\u662f\u8bf7\u6ce8\u610f\uff0c\u8fd9\u53ef\u80fd\u4f1a\u8f6c\u5316\u4e3a\u53ef\u7528\u6027\u635f\u5931\u3002\u4f8b\u5982\uff0c\u5982\u679c\u5927\u591a\u6570\u5b9e\u4f8b\u5d29\u6e83\uff0c\u7cfb\u7edf\u5c06\u5728 TTL \u671f\u95f4\u5168\u5c40\u4e0d\u53ef\u7528\uff08\u8fd9\u91cc\u5168\u5c40\u610f\u5473\u7740\u5728\u6b64\u671f\u95f4\u6839\u672c\u6ca1\u6709\u8d44\u6e90\u53ef\u9501\u5b9a\uff09\u3002"]}),"\n",(0,n.jsx)(t.h2,{id:"making-the-algorithm-more-reliable-extending-the-lock",children:"Making the algorithm more reliable: Extending the lock"}),"\n",(0,n.jsx)(t.p,{children:"If the work performed by clients is composed of small steps, it is possible to use smaller lock validity times by default, and extend the algorithm implementing a lock extension mechanism. Basically the client, if in the middle of the computation while the lock validity is approaching a low value, may extend the lock by sending a Lua script to all the instances that extends the TTL of the key if the key exists and its value is still the random value the client assigned when the lock was acquired."}),"\n",(0,n.jsx)(t.p,{children:"\u5982\u679c\u5ba2\u6237\u7aef\u6267\u884c\u7684\u5de5\u4f5c\u7531\u5c0f\u6b65\u9aa4\u7ec4\u6210\uff0c\u5219\u53ef\u4ee5\u9ed8\u8ba4\u4f7f\u7528\u8f83\u5c0f\u7684\u9501\u6709\u6548\u65f6\u95f4\uff0c\u5e76\u6269\u5c55\u5b9e\u73b0\u9501\u6269\u5c55\u673a\u5236\u7684\u7b97\u6cd5\u3002\u57fa\u672c\u4e0a\u5ba2\u6237\u7aef\uff0c\u5982\u679c\u5728\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\u9501\u6709\u6548\u6027\u63a5\u8fd1\u4e00\u4e2a\u4f4e\u503c\uff08\u5feb\u8fc7\u671f\u4e86\uff09\uff0c\u53ef\u4ee5\u901a\u8fc7\u5411\u6240\u6709\u5b9e\u4f8b\u53d1\u9001\u4e00\u4e2a Lua \u811a\u672c\u6765\u6269\u5c55\u9501\uff0c\u6761\u4ef6\u662f\u5bc6\u94a5\u5b58\u5728\u5e76\u4e14\u5b83\u7684\u503c\u4ecd\u7136\u662f\u83b7\u53d6\u9501\u65f6\u5ba2\u6237\u7aef\u5206\u914d\u7684\u968f\u673a\u503c\u3002"}),"\n",(0,n.jsx)(t.p,{children:"The client should only consider the lock re-acquired if it was able to extend the lock into the majority of instances, and within the validity time (basically the algorithm to use is very similar to the one used when acquiring the lock)."}),"\n",(0,n.jsx)(t.p,{children:"\u5982\u679c\u5ba2\u6237\u7aef\u80fd\u591f\u5c06\u9501\u6269\u5c55\u5230\u5927\u591a\u6570\u5b9e\u4f8b\uff0c\u5e76\u4e14\u5728\u6709\u6548\u65f6\u95f4\u5185\uff08\u57fa\u672c\u4e0a\u4f7f\u7528\u7684\u7b97\u6cd5\u4e0e\u83b7\u53d6\u9501\u65f6\u4f7f\u7528\u7684\u7b97\u6cd5\u975e\u5e38\u76f8\u4f3c\uff09\uff0c\u5ba2\u6237\u7aef\u5e94\u8be5\u53ea\u8003\u8651\u91cd\u65b0\u83b7\u53d6\u9501\u3002"}),"\n",(0,n.jsx)(t.p,{children:"However this does not technically change the algorithm, so the maximum number of lock reacquisition attempts should be limited, otherwise one of the liveness properties is violated."}),"\n",(0,n.jsx)(t.p,{children:"\u7136\u800c\uff0c\u8fd9\u5728\u6280\u672f\u4e0a\u5e76\u6ca1\u6709\u6539\u53d8\u7b97\u6cd5\uff0c\u56e0\u6b64\u5e94\u8be5\u9650\u5236\u91cd\u65b0\u83b7\u53d6\u9501\u7684\u6700\u5927\u5c1d\u8bd5\u6b21\u6570\uff0c\u5426\u5219\u4f1a\u8fdd\u53cd liveness properties \u4e4b\u4e00\u3002"}),"\n",(0,n.jsx)(t.h2,{id:"want-to-help",children:"Want to help?"}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.p,{children:"If you are into distributed systems, it would be great to have your opinion / analysis. Also reference implementations in other languages could be great."}),"\n",(0,n.jsx)(t.p,{children:"\u5982\u679c\u60a8\u8fdb\u5165\u5206\u5e03\u5f0f\u7cfb\u7edf\uff0c\u90a3\u4e48\u6709\u60a8\u7684\u610f\u89c1/\u5206\u6790\u4f1a\u5f88\u68d2\u3002\u5176\u4ed6\u8bed\u8a00\u7684\u53c2\u8003\u5b9e\u73b0\u4e5f\u53ef\u80fd\u5f88\u68d2\u3002"}),"\n",(0,n.jsx)(t.p,{children:"Thanks in advance!"})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1151:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>l});var n=i(7294);const s={},a=n.createContext(s);function l(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);